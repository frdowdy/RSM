---
title: "dna_analysis"
output:
  html_document: default
  html_notebook: default
---

First we're going to set up R to to our target directory and clear the workspace.
```{r setup}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE, 
                      message = FALSE,
                      engine = "R", # Chunks will always have R code, unless noted
                      error = TRUE,
                      fig.path="Figures/",  # Set the figure options
                      fig.align = "center",
                      dev='png')

```

Clear RStudio
```{r clear}
  # cat(rep("\n",50)) # Clear Console
  rm(list=ls(all=TRUE)) # clear workspace
  graphics.off() # closes all graphics
```

Install functions
```{r }
source("R/functions.R")
```
Install packages
```{r}
packages(tidyverse)
packages(broom)
packages(devtools) # List additional needed packages here on new lines with "packages(NAME)"
packages(survival) # dependency for microbiome package
packages(Formula) # dependency for microbiome package
packages(ggplot2) # dependency for microbiome package
packages(acepack) # dependency for microbiome package
packages(base64enc) # dependency for microbiome package
packages(gridExtra) # dependency for microbiome package
packages(htmltools)
packages(stringi)
packages(htmlTable) # dependency for microbiome package
packages(data.table) # dependency for microbiome package
packages(permute) # dependency for microbiome package
packages(ggthemes)
packages(GGally)
packages(survival)
source("https://bioconductor.org/biocLite.R")
# biocLite("WGCNA")
# biocLite("preprocessCore")
# install_github("jtclaypool/microbiome")
#missing dependencies may need to be installed from Bioconductor
#install missing packages by (for preprocessCore):
#source("https://bioconductor.org/biocLite.R")
#biocLite("preprocessCore")
packages(microbiome)
```

```{r get dummy data, message = FALSE, warning=FALSE}
#metadata

meta <- read_csv("data/meta_dummy.csv") %>% filter(!is.na(`Sample Name`))
#filter for samples of interest (anode here)
meta <- meta %>% filter(str_sub(`Sample Label`,-1,-1)=="A")
# meta <- meta %>% filter(str_sub(`Sample Label`,-1,-1)=="A" | str_sub(`Sample Label`,-1,-1)==1|str_sub(`Sample Label`,-1,-1)==2 )
#paste on suffixes used by sequencing company
sample_labels_of_interest <- meta %>% select(`Sample Label`) %>% unlist %>% paste("-MS515F",sep = "")
#filter dna seq data for samples of interest and read in
dummy_dna_seq_of_interest <- read_tsv("data/dummy_data.txt",skip=1) %>% 
  select(`#OTU ID`,sample_labels_of_interest,ConsensusLineage)

# have to add in first line "# Constructed from biom file"
cat("# Constructed from biom file","\n",file="output/dummy_dna_seq_of_interest.txt")
write.table(dummy_dna_seq_of_interest,file="output/dummy_dna_seq_of_interest.txt",append = TRUE,row.names=FALSE,quote = FALSE,sep = "\t")

biom <- read.biom("output/dummy_dna_seq_of_interest.txt")
rm(dummy_dna_seq_of_interest)
```

Fix Metadata
```{r fix metadata}
# This section fixes the metadata to match between the metadata labels and the R biome labels
  # Note that R puts an X in front of any column header that starts with a number, and dashes and other special characters are replaced by periods
labels <- meta %>% select(`Sample Label`) %>% unlist %>% paste("-MS515F",sep = "") 
meta$`Sample Label`<- ifelse(!is.na(as.numeric(str_sub(labels,1,1))), paste("X",labels,sep = ""), paste("",labels,sep = "")) %>% gsub("-",".", .)
```

Make dummy data resemble Exp23 RSM data set of 15 samples
```{r}
meta <- meta %>% mutate(mfc=as.numeric(str_extract(`Sample Name`,"\\d+")))
meta <- meta %>% select(`Sample Label`,mfc) %>% left_join(.,read_csv("rsm_hist.csv")[,1:4])
meta <- meta %>% dplyr::rename(Label = `Sample Label`)
meta <- as.data.frame(meta)
```

#Sample vs OTU
```{r Simple Relative Abundance}
# Here we can make our generic barplot of relative abundance. We can also then transform it into something fancier!
ra_plot=barplot_RA(biom$RA.Otus,tax = biom$taxon,meta = meta,category = "temp",top = 5)

# plot is stored in list variable RA_plot
# RA_plot is a ggplot2 object and can be manipulated according to make publication ready graph
# for example adding an x-axis label and changing the legend title

ggplot(data = ra_plot$top_long,aes(x=factor(label,levels = c("-1","0","1")),y=value,fill=variable))+ # this reorders x     axis values
  geom_bar(stat="identity")+
  scale_x_discrete("Temperature")+ # Labels categorical labels on x axis
  ylab("Relative Abundance (%)")+ 
  theme(legend.title=element_text(),legend.position="right",plot.title = element_text(hjust=0.5))+
  guides(fill=guide_legend("Phylum"))+
  theme_few()

ra_plot=barplot_RA(biom$RA.Otus,tax = biom$taxon,meta = meta,category = "acetate",top = 5)

ggplot(data = ra_plot$top_long,aes(x=factor(label,levels = c("-1","0","0.5","1")),y=value,fill=variable))+ # this reorders x     axis values
  geom_bar(stat="identity")+
  scale_x_discrete("Acetate")+ # Labels categorical labels on x axis
  ylab("Relative Abundance (%)")+ 
  theme(legend.title=element_text(),legend.position="right",plot.title = element_text(hjust=0.5))+
  guides(fill=guide_legend("Phylum"))+
  theme_few()
```
```{r nmds plots}
veg=vegan_wrapper(biom$RA.Otus,meta = meta,category_1 = "temp",category_2 = "acetate")

veg$NMDS_plot+
    theme_few()+
    scale_shape_discrete(name="Acetate")+
    scale_colour_discrete(name = "Temperature")
    
# pull data out to better make plot
NMDS.data <- veg$NMDS_plot$data
NMDS.data <- NMDS.data %>% mutate_at(vars(category_1,category_2),funs(as.factor))

# https://gist.github.com/rmaia/5296401
 ggplot(data=NMDS.data, aes(x=MDS1, y=MDS2, color=category_1)) + geom_point(aes(shape=category_2),size=3)+
       scale_shape_manual(name = "Acetate",values=15:18)+
    # scale_colour_discrete(name = "Temperature")+
   scale_colour_grey(name = "Temperature", start = 0.2, end = 0.8)
   
  

```
```{r ecological metrics}
# calc richnness, evenness, diversity each community
# diversity
div <- diversity(biom$RA.Otus, index = "shannon")
# richness
rich <- specnumber(biom$RA.Otus)
# evenness
even <- diversity(biom$RA.Otus, index = "shannon")/log(specnumber(biom$RA.Otus))
# all in one
rsm_hist <- data.frame(Label = names(div),diversity = div,richness = rich,evenness = even,row.names = NULL) %>% 
  left_join(meta,.) %>% 
  left_join(read_csv("rsm_hist.csv"),.) %>% #data from first script RSM_code.Rmd. Start building rsm_hist here in script.
  arrange(mfc)
```

```{r rsm of ecological metrics}
# without validation points, then stepped with AIC
dfVariable <- rsm_hist %>% select(mfc,type,temp,acetate,diversity,richness,evenness) %>% 
  filter(type!="validation") %>% 
  gather("variable","value",c(5:ncol(.))) %>% 
  group_by(variable) %>% 
  do(fitVariable = step(trace=0,lm(value ~ temp+acetate+I(temp^2)+I(acetate^2)+temp:acetate, data = .)))

# get the coefficients by group in a tidy data_frame
dfVariableCoef = tidy(dfVariable, fitVariable)
dfVariableCoef

# get the predictions by group in a tidy data_frame 
dfVariablePred = augment(dfVariable,fitVariable)
dfVariablePred

# get the summary statistics by group in a tidy data_frame
dfVariableSumm = glance(dfVariable, fitVariable)
dfVariableSumm


# get all significant models
dfVariableSumm %>% filter(p.value<=.05) %>% select(variable) %>% unique() %>% as.matrix() %>% match(.,dfVariable$variable) -> sig_models
dfVariable$variable[sig_models]

# loop it and provide titles - looks like it doesn't know what to do when acetate coefficients are undefined
alternativeFunction <- function(){
    newdat = data.frame(temp = seq(min(rsm_hist$temp),max(rsm_hist$temp),length.out = 100))
  newdat$pred = predict(model, newdata = newdat)
  plot(unlist(rsm_hist[dfVariable$variable[i]]) ~ temp, data = rsm_hist, main = paste(dfVariable$variable[i],"excluding validation points (AIC model)"),xlab="Temperature",ylab=dfVariable$variable[i])
  with(newdat, lines(x = temp, y = pred))
    }

for(i in sig_models){
  require(rsm)
  dfVariable$fitVariable[i] %>% unlist(recursive = FALSE) %>% structure(class = "lm") -> model
t <- try(
  persp(model, ~ temp + acetate, col = rainbow(50), contours = "colors", main = paste(dfVariable$variable[i],"excluding validation points (AIC model)")))
if("try-error" %in% class(t)) 
  alternativeFunction()
}

```
Also a good idea to try transforming data and doing RSM.
```{r}
rsm_hist <- rsm_hist %>% select(diversity,richness,evenness) %>% apply_transform %>% cbind(rsm_hist,.)

# without validation points, then stepped with AIC
dfVariable <- rsm_hist %>% select(mfc,type,temp,acetate,trans_diversity,trans_richness,trans_evenness) %>% 
  filter(type!="validation") %>% 
  gather("variable","value",c(5:ncol(.))) %>% 
  group_by(variable) %>% 
  do(fitVariable = step(trace=0,lm(value ~ temp+acetate+I(temp^2)+I(acetate^2)+temp:acetate, data = .)))

# get the coefficients by group in a tidy data_frame
dfVariableCoef = tidy(dfVariable, fitVariable)
dfVariableCoef


# # get the predictions by group in a tidy data_frame 
dfVariablePred = augment(dfVariable,fitVariable)
dfVariablePred

# get the summary statistics by group in a tidy data_frame
dfVariableSumm = glance(dfVariable, fitVariable)
dfVariableSumm


# get all significant models
dfVariableSumm %>% filter(p.value<=.05) %>% select(variable) %>% unique() %>% as.matrix() %>% match(.,dfVariable$variable) -> sig_models
dfVariable$variable[sig_models]

# This should probably be turned into a function in the functions.R script
# loop it and provide titles - looks like it doesn't know what to do when acetate coefficients are undefined
alternativeFunction <- function(){
    newdat = data.frame(temp = seq(min(rsm_hist$temp),max(rsm_hist$temp),length.out = 100))
  newdat$pred = predict(model, newdata = newdat)
  plot(unlist(rsm_hist[dfVariable$variable[i]]) ~ temp, data = rsm_hist, main = paste(dfVariable$variable[i],"excluding validation points (AIC model)"),xlab="Temperature",ylab=dfVariable$variable[i])
  with(newdat, lines(x = temp, y = pred))
    }

for(i in sig_models){
  dfVariable$fitVariable[i] %>% unlist(recursive = FALSE) %>% structure(class = "lm") -> model
t <- try(
  persp(model, ~ temp + acetate, col = rainbow(50), contours = "colors", main = paste(dfVariable$variable[i],"excluding validation points (AIC model)")))
if("try-error" %in% class(t)) 
  alternativeFunction()
}

```
#OTUs vs Clusters
```{r Co-occurrence across all OTUs, message = FALSE, warning=FALSE,fig.width=9,fig.height=9}
  
  # This is an area of networks where we study OTU's in the same environment that "co-occur". First we will filter data by co-occurence. Minimum recommended is 20%.
  
  #filter OTU's to 50% presence in all samples
  biom_fil=cooccur_filter(RA=biom$RA.Otus,co_per=0.5)
  
  #run co-occurence. Taxon can be excluded and identified later if desired.
  biom_netw=cooccurrence(biom_fil,taxon = biom$taxon)
  
  #try plotting the data
  # plot.igraph(biom_netw$netw) # standard plot function for igraph package
  # tkplot(biom_netw$netw) #interactive plot viewer
  # rglplot(biom_netw$netw) #experimental 3d plot viewer
  
  #Or by using ggnet2 (https://briatte.github.io/ggnet/)
  packages(network)
  packages(sna)
  packages(RColorBrewer)
  packages(intergraph)
  
  # Visualize
  set.seed(101)
  (network_plot <- ggnet2(biom_netw$netw, size = 6, color = "tomato", label=T, label.size=2))
```
Cluster network plot
```{r plot community networks,fig.width=12,fig.height=9}
# infomap community detection. Try the different detection algorithms to understand how different your niches might be broken up
biom_info=infomap.community(biom_netw$netw)


#now add some color to your previous plot (Josh's Method)
  #plot(biom_netw$netw,vertex.color=as.factor(biom_info$membership))
  
#Create a custom color scale
n <- max(biom_info$membership)
library(RColorBrewer)
myColors <- colorRampPalette(brewer.pal(12, "Paired"))(n)
names(myColors) <- levels(as.factor(biom_info$membership))
colScale <- scale_colour_manual(name = "Cluster",values = myColors)

#Plot with ggnet
nodesize <- 8
set.seed(101)
(plot_ggnet <- ggnet2(biom_netw$netw, size = nodesize, 
                      node.color = as.factor(biom_info$membership), 
                      color.legend = "Cluster",
                      label=T, 
                      label.size=2)+
    colScale+
    guides(colour = guide_legend(override.aes = list(size=nodesize))))
    

``` 
#Samples vs KOs
```{r heat maps of KOs across treatments}
# get metagenome data from PICRUST
predicted_metagenome = read.biom("C:/Users/Ryan/Google Drive/UC Davis/Dissertation for PhD/data/Exp23/dummy_metagenome.tab",new=T,metagenome=T)
# predicted_metagenome$RA.genes[1:10,1:10] # View data # Note this gives relative abundance in percent from 0 to 100

# Modify data to align it               -
meta$Label
rownames(predicted_metagenome$RA.genes) # see if row names match up in same order
predicted_metagenome$RA.genes <- predicted_metagenome$RA.genes[match(meta$Label,rownames(predicted_metagenome$RA.genes)),]
rownames(predicted_metagenome$RA.genes)

# Aggregate genes by sample (try first just by temp)
genes_agg = aggregate(predicted_metagenome$RA.genes,by=list(meta$temp),FUN=mean)
# Convert wide format into long format table
genes_melt=melt(genes_agg,id="Group.1")
# Filter by whatever genes of interest
kos_exoelectrogenic <- read.csv("data/kos_exoelectrogenic.csv",header=FALSE,fileEncoding="UTF-8-BOM")
genes_filtered <- genes_melt[which(genes_melt$variable %in% unlist(kos_exoelectrogenic)),]
# Make heat map
genes_filtered %>% 
  ggplot(data=.,aes(x=Group.1,y=variable,fill=value))+
  geom_tile()+
  scale_fill_gradient2("Scaled gene relative abundance \n",guide="colourbar",high="#FF5733",low="#FDFEFE")+
  xlab("Sample")+
  ylab("KEGG Ortholog")
# Now what if we rescale the data row-wise?
genes_filtered %>% 
  group_by(variable) %>% 
  mutate(rescale = scales::rescale(value)) %>% # this rescales each value 0:1 by variable
  ggplot(data=.,aes(x=Group.1,y=variable,fill=rescale))+
  geom_tile()+
  scale_fill_gradient2("Scaled gene relative abundance \n",guide="colourbar",high="#FF5733",low="#FDFEFE")+
  xlab("Sample")+
  ylab("KEGG Ortholog")

# Aggregate genes by sample (try by acetate)
genes_agg = aggregate(predicted_metagenome$RA.genes,by=list(meta$acetate),FUN=mean)
# Convert wide format into long format table
genes_melt=melt(genes_agg,id="Group.1")
# Filter by whatever genes of interest
kos_exoelectrogenic <- read.csv("data/kos_exoelectrogenic.csv",header=FALSE,fileEncoding="UTF-8-BOM")
genes_filtered <- genes_melt[which(genes_melt$variable %in% unlist(kos_exoelectrogenic)),]
# Make heat map
genes_filtered %>% 
  ggplot(data=.,aes(x=Group.1,y=variable,fill=value))+
  geom_tile()+
  scale_fill_gradient2("Scaled gene relative abundance \n",guide="colourbar",high="#FF5733",low="#FDFEFE")+
  xlab("Sample")+
  ylab("KEGG Ortholog")
# Now what if we rescale the data row-wise?
genes_filtered %>% 
  group_by(variable) %>% 
  mutate(rescale = scales::rescale(value)) %>% # this rescales each value 0:1 by variable
  ggplot(data=.,aes(x=Group.1,y=variable,fill=rescale))+
  geom_tile()+
  scale_fill_gradient2("Scaled gene relative abundance \n",guide="colourbar",high="#FF5733",low="#FDFEFE")+
  xlab("Sample")+
  ylab("KEGG Ortholog")

```
```{r RSM of each exoelectrogenic KO to temp and acetate}
# Aggregate genes by treatment or mfc in this case
genes_agg <- predicted_metagenome$RA.genes %>% mutate(Label = rownames(.)) %>% select(Label,everything())
# Convert wide format into long format table
genes_melt <- genes_agg %>% gather(.,key = "variable",value = "value",-Label)
# Filter by whatever genes of interest
genes_filtered <- genes_melt[which(genes_melt$variable %in% unlist(kos_exoelectrogenic)),]
#append to rsm_hist
rsm_hist <- genes_filtered %>% spread(variable,value) %>% left_join(rsm_hist,.,by="Label")
#apply transform
rsm_hist <- rsm_hist %>% select(starts_with("K")) %>% apply_transform %>% bind_cols(rsm_hist,.)
#run rsm and visualize
source("R/functions.R")
rsm_object <- rsm_and_visualize(data = rsm_hist,response_cols = rsm_hist %>% select(starts_with("trans_K")) %>% colnames)
rsm_object
```
#Clusters vs KOs
```{r aggregate KOs by network cluster}
# Read in metagenome contributions table (takes 2 min to read)
a <- proc.time()
ko_metagenome_contributions <- read.table("C:/Users/Ryan/Google Drive/UC Davis/Dissertation for PhD/data/Exp23/dummy_metagenome_contributions.tab", header = T, sep = "\t", fill=TRUE)
proc.time()-a
# chop off unnecessary phylogeny
ko_metagenome_contributions <- ko_metagenome_contributions %>% select(-c(Kingdom,Phylum,Class,Order,Family,Genus,Species))
# which quantitative column is of interest? GeneCountPerGenome because it's the only one that doesn't involve relative abundance normalized to sample

# create lookup table
otu_cluster_lookup <- data.frame("OTU" = biom_info$names,"Cluster" = biom_info$membership)
# Lookup cluster number from lookup table
ko_metagenome_contributions$Cluster <- otu_cluster_lookup[match(ko_metagenome_contributions$OTU,otu_cluster_lookup$OTU),"Cluster"]

#filter out NA clusters
filt_ko_metagenome_contributions <- ko_metagenome_contributions[!is.na(ko_metagenome_contributions$Cluster),]
#remove unnecessary columns
filt_ko_metagenome_contributions <- filt_ko_metagenome_contributions %>% select(-c(OTUAbundanceInSample,CountContributedByOTU,ContributionPercentOfSample,ContributionPercentOfAllSamples))
head(filt_ko_metagenome_contributions)

# within each cluster, sum GeneCountPerGenome by Gene
filt_ko_metagenome_contributions <- aggregate(GeneCountPerGenome~Gene+Cluster,filt_ko_metagenome_contributions,sum)

# calc relative abundance of KOs within total KO GeneCountPerGenome in cluster
filt_ko_metagenome_contributions <- filt_ko_metagenome_contributions %>% group_by(Cluster) %>% mutate(relAbundByCluster = GeneCountPerGenome / sum(GeneCountPerGenome))

# filter by target KOs
filt_ko_metagenome_contributions <- filt_ko_metagenome_contributions[which(filt_ko_metagenome_contributions$Gene %in% unlist(kos_exoelectrogenic)),]

# tidy up names
colnames(filt_ko_metagenome_contributions) <- c("Gene","Cluster","GeneCount","relAbund")

# Rescale 0 to 1 for heat map
filt_ko_metagenome_contributions %>%  
  group_by(Gene)%>% 
  mutate(rescale = scales::rescale(relAbund)) %>% 
  ggplot(data=.,aes(x=factor(Cluster),y=Gene,fill=rescale))+
  geom_tile()+
  scale_fill_gradient2("Rescaled gene relative abundance \n",guide="colourbar",high="#FF5733",low="#FDFEFE")+
  xlab("Cluster")+
  ylab("KEGG Ortholog")+
  theme_few()+
 scale_x_discrete(expand = c(0,0))+
 scale_y_discrete(expand = c(0,0)) +
 coord_fixed(ratio=1)
```
```{r anova on which clusters have highest proportion of exoelectrogenic KOs}
filt_ko_metagenome_contributions %>%  select(-GeneCount) %>% 
  spread(Gene,relAbund) %>% arrange(Cluster) -> data
data %>% .[,-1] %>% apply_transform %>% bind_cols(data[,1],.) -> data

#plot
data %>% gather(key = "KO",value = "value",-Cluster) %>% 
ggplot(., aes(x=factor(Cluster), y = value)) +
    geom_boxplot(fill = "grey80", colour = "blue") +
    scale_x_discrete() + xlab("Cluster") +
    ylab("Transformed KO relative abundance") +
    theme_few()
#anova
data %>% 
  gather(key = "KO",value = "value",-Cluster) %>% 
  aov(value~factor(Cluster),data = .) %>% 
  summary
data %>% 
  gather(key = "KO",value = "value",-Cluster) %>% 
  aov(value~factor(Cluster),data = .) %>% 
  TukeyHSD -> Tukey
  Tukey$`factor(Cluster)`[Tukey$`factor(Cluster)`[,4]<.2,]

```
#Cluster vs Sample
```{r}
#assign clusters of interest
clusofinterest <- Tukey$`factor(Cluster)`[Tukey$`factor(Cluster)`[,4]<.2,] %>% rownames %>% as_tibble %>% separate(value,c("Cluster1","Cluster2")) %>% unlist %>% as.numeric %>% table %>% as_tibble %>% filter(n>1) %>% .[,1] %>% unlist %>% as.numeric

# make a long form table we can aggregate
ix <- which(colnames(biom$biom_tab) %in% c("Kingdom","Phylum","Class","Order","Family","Genus","Species")) # remove taxonomy info
data <- biom$biom_tab[,-ix] 
data <- t(data)
data <- melt(data)
colnames(data) <- c("Label","OTU","Reads")
#assign clusters to OTUs
data$Cluster <- otu_cluster_lookup[match(data$OTU,otu_cluster_lookup$OTU),"Cluster"]
# aggregate reads by label and cluster
agg_data <- aggregate(data$Reads,
    by = list(Label = data$Label, Cluster = data$Cluster),
    FUN = function(x) c(sum = sum(x)))
colnames(agg_data) <- c("Label","Cluster","Cluster_reads_in_label")
# aggregate reads by label
agg_data_label <- aggregate(data$Reads,
    by = list(Label = data$Label),
    FUN = function(x) c(sum = sum(x)))
# attach to agg_data
agg_data$label_reads <- agg_data_label[match(agg_data$Label,agg_data_label$Label),"x"]
# RA
agg_data$RA_cluster_in_label <- 100*agg_data$Cluster_reads_in_label/agg_data$label_reads

#reformat and attach to rsm_hist
agg_data %>% select(Label,Cluster,RA_cluster_in_label) %>% spread(key = Cluster,value = RA_cluster_in_label) -> data
colnames(data) %>% paste("cluster_",.,sep = "")->name_vector
"Label"->name_vector[1]
colnames(data) <- name_vector
data %>% left_join(rsm_hist,.,by = "Label") -> rsm_hist
data %>% .[,-1] %>% apply_transform %>% bind_cols(as_tibble(data$Label),.) %>% dplyr::rename("Label" = value) %>% left_join(rsm_hist,.,by = "Label") -> rsm_hist

#run rsm and visualize
source("R/functions.R")
rsm_object <- rsm_and_visualize(data = rsm_hist,response_cols = rsm_hist %>% select(starts_with("cluster")) %>% colnames)
rsm_object

```


